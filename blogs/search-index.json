[
  {
    "title": "JSON Web Token认证方案",
    "slug": "JWT认证方案",
    "summary": "\nJSON Web Token（JWT）是当今最流行的跨域认证解决方案之一，广泛应用于分布式系统和前后端分离架构中。本文将详细介绍 JWT 的原理、结构、使用方式及其优缺点，理解其在现代 Web 开发中的重要性。\n\n## 一、跨域认证的挑战\n\n在互联网服务中，用户认证是不可或缺的一环。传统的认证流程通常如下：\n\n1. 用户向服务器发送用户名和密码。\n2. 服务器验证通过后，在会话（session）中存储用户相关信息，如用户 ID、角色、登录时间等。\n3. 服务器返回一个 session_id，存储在客户端的 Cookie 中。\n4. 后续请求中，客户端通过 Cookie 自动携带 session_id，服务器根据 session_id 查找会话数据以确认用户身份。\n5. 服务器根据会话数据处理请求并返回结果。\n\n这种基于 session 的认证方式在单机环境中运行良好，但在分布式系统或跨域场景中面临扩展性问题。例如，假设 A 和 B 是同一公司的两个网站，用户在 A 网站登录后，希望访问 B 网站时自动登录。如何实现？\n",
    "content": "JSONWebTokenJWT是当今最流行的跨域认证解决方案之一广泛应用于分布式系统和前后端分离架构中本文将详细介绍JWT的原理结构使用方式及其优缺点理解其在现代Web开发中的重要性一跨域认证的挑战在互联网服务中用户认证是不可或缺的一环传统的认证流程通常如下用户向服务器发送用户名和密码服务器验证通过后在会话session中存储用户相关信息如用户ID角色登录时间等服务器返回一个session_id存储在客户端的Cookie中后续请求中客户端通过Cookie自动携带session_id服务器根据session_id查找会话数据以确认用户身份服务器根据会话数据处理请求并返回结果这种基于session的认证方式在单机环境中运行良好但在分布式系统或跨域场景中面临扩展性问题例如假设A和B是同一公司的两个网站用户在A网站登录后希望访问B网站时自动登录如何实现传统方案的局限性会话数据共享在服务器集群中每台服务器需要访问共享的session数据通常通过数据库或Redis实现这增加了工程复杂性且持久层可能成为单点故障跨域限制不同域名下的Cookie无法直接共享导致跨域单点登录SSO实现困难扩展性问题随着用户量和服务器数量增加集中式session管理可能导致性能瓶颈JWT提供了一种无状态的认证方案通过将用户身份信息存储在客户端解决了上述问题二JWT的原理JWT的核心理念是服务器在验证用户身份后生成一个包含用户信息的JSON对象附加签名后发回客户端客户端在后续请求中携带此JSON对象服务器仅通过验证签名即可确认用户身份无需在服务器端存储会话数据例如服务器可能生成如下JSON对象user_id12345,roleadmin,exp1735689600这个JSON对象经过编码和签名后形成JWT令牌客户端每次请求时携带该令牌服务器验证其有效性以确认用户身份由于服务器无需存储会话数据这种方式天然适合分布式系统和跨域场景三JWT的数据结构JWT是一个由三部分组成的字符串用点号.分隔形如Header.Payload.Signature每一部分都是Base64URL编码的字符串具体作用如下3.1Header头部Header是一个JSON对象描述JWT的元数据通常包含以下字段algHS256,typJWTalg签名算法通常为HMACSHA256HS256或RSAtyp令牌类型固定为JWTHeader被Base64URL编码后形成JWT的第一部分3.2Payload负载Payload包含实际的用户数据分为官方字段和自定义字段JWT规范定义了以下官方字段ississuer签发者例如auth.example.comsubsubject主题通常是用户ID如12345audaudience受众指定令牌的接收方如api.example.comexpexpirationtime过期时间Unix时间戳如1735689600nbfnotbefore生效时间Unix时间戳iatissuedat签发时间Unix时间戳jtiJWTID唯一标识用于防止令牌重放自定义字段可以根据业务需求添加例如sub12345,name张三,roleadminPayload同样被Base64URL编码形成JWT的第二部分注意Payload默认不加密任何人都可以解码读取因此不应包含敏感信息如密码3.3Signature签名Signature用于验证JWT的完整性和真实性防止数据被篡改其生成公式为HMACSHA256base64UrlEncodeheader.base64UrlEncodepayload,secretsecret服务器私有的密钥仅服务器知道HMACSHA256默认签名算法也可使用RSA等非对称加密算法签名后HeaderPayload和Signature通过点号拼接形成完整的JWT例如eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuoYiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MzU2ODk2MDB9.dQw4w9WgXcQ3.4Base64URL编码Base64URL是一种适合URL传输的编码方式与标准Base64类似但有以下调整去掉填充字符将替换为将替换为_这确保JWT可以在URL中安全传输例如api.example.com?tokenxxx四JWT的使用方式4.1客户端存储客户端收到JWT后可以存储在以下位置Cookie通过SetCookie头自动发送但不适合跨域场景受同源策略限制localStoragesessionStorage适合前后端分离场景需手动添加到请求头HTTP请求头推荐方式将JWT放入Authorization头例如AuthorizationBearereyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...4.2跨域单点登录在跨域场景中JWT的无状态特性尤为重要例如用户在A网站a.example.com登录服务器验证后返回JWT客户端将JWT存储在localStorage或通过POST请求传递访问B网站b.example.com时客户端在请求头中携带JWTB网站的服务器使用共享的密钥验证JWT提取用户身份如sub实现自动登录4.3服务器验证服务器收到JWT后使用相同的密钥和算法重新计算签名比较计算出的签名与JWT中的签名是否一致检查Payload中的exp过期时间nbf生效时间等字段是否有效根据sub或其他字段确认用户身份处理请求五JWT的特点与优缺点5.1特点无状态性服务器不存储会话数据适合分布式系统和微服务架构跨域友好JWT存储在客户端适合跨域单点登录信息交换Payload可携带用户数据减少服务器查询如获取用户角色可扩展性支持多种签名算法如HS256RS256和加密方式5.2优点扩展性强无需共享session数据适合服务器集群和微服务跨域支持通过HTTP头或POST数据传递JWT实现跨域认证减少服务器开销无需在服务器端存储会话降低内存和数据库压力标准化遵循RFC7519规范社区支持广泛库实现丰富如jsonwebtoken5.3缺点无法主动失效由于无状态设计服务器无法在过期前主动废除JWT例如用户在设备A登录后又在设备B登录设备A的JWT仍有效除非添加额外逻辑如黑名单安全性风险JWT默认不加密Payload可被解码需避免存储敏感信息盗用风险若JWT被窃取如通过XSS攻击攻击者在有效期内可冒用身份建议设置较短的过期时间并使用HTTPS传输数据膨胀JWT包含HeaderPayload和Signature数据量较大可能增加网络开销5.4解决缺点的方法短过期时间设置较短的exp如15分钟配合refreshtoken刷新黑名单机制在Redis中维护失效JWT的jti列表检查令牌是否被废除防止重放攻击使用jti和一次性nonce或在Payload中加入时间戳验证请求的唯一性加密JWT使用JWEJSONWebEncryption对Payload加密增强安全性六JWT的应用场景单点登录SSO在多个子域名或服务间共享用户身份例如用户在auth.example.com登录后访问api.example.com时自动认证前后端分离在RESTfulAPI中客户端如ReactVue通过JWT认证用户第三方授权结合OAuth2.0JWT作为访问令牌减少对授权服务器的查询移动端认证在移动应用中JWT适合无状态认证减少服务器压力七实际示例假设一个简单的登录场景用户在前端输入用户名和密码发送到login接口服务器验证后生成JWTheaderalgHS256,typJWT,payloadsub12345,name张三,roleadmin,exp1735689600,iat1735686000服务器使用密钥mysecretkey生成签名返回JWTeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuoYiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MzU2ODk2MDAsImlhdCI6MTczNTY4NjAwMH0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c客户端存储JWT例如在localStorage并在后续请求中添加AuthorizationBearereyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...服务器验证JWT的签名和有效期提取sub确认用户身份八常见问题解答8.1如何实现单设备登录若要求设备B登录后使设备A的JWT失效可在服务器端维护一个Redis表记录用户ID和最新JWT的jti验证时检查jti是否匹配不匹配则拒绝请求此方案虽引入少量状态但比session管理更轻量8.2如何防止JWT被盗用使用HTTPS加密传输防止中间人攻击设置较短的过期时间如15分钟并使用refreshtoken刷新在Payload中加入设备指纹如IP或设备ID增加验证条件通过XSS防护如CSP防止客户端存储的JWT被窃取8.3JWT与session的选择选择JWT的场景跨域认证前后端分离分布式系统第三方授权选择session的场景单机系统高安全性需求需频繁修改用户权限九总结JWT是一种轻量无状态的认证方案通过将用户身份信息编码为令牌解决了传统session在分布式和跨域场景中的局限性其标准化的结构HeaderPayloadSignature和灵活的使用方式使其成为现代Web开发的首选认证工具然而JWT的无状态特性也带来了无法主动失效和潜在的安全风险需要通过短过期时间黑名单机制和HTTPS等措施弥补理解JWT的原理和适用场景能帮助开发者设计更安全高效的认证系统",
    "tags": [
      "安全",
      "Web",
      "架构"
    ],
    "category": "Technology",
    "date": "2019-05-23"
  },
  {
    "title": "React服务端组件深度解析",
    "slug": "React服务端组件深度解析",
    "summary": "\nReact Server Components (RSC) 是 React 18 引入的革命性特性，它重新定义了我们构建 React 应用的方式。\n\n## 核心特性\n\n- [x] **[zero-bundle-impact]** 服务端组件不会增加客户端 bundle 大小\n- [x] **[direct-data-access]** 可以直接访问后端资源（数据库、文件系统等）\n- [x] **[automatic-code-splitting]** 自动代码分割，按需加载\n- [x] **[streaming-support]** 支持流式渲染，提升用户体验\n",
    "content": "ReactServerComponentsRSC是React18引入的革命性特性它重新定义了我们构建React应用的方式核心特性xzerobundleimpact服务端组件不会增加客户端bundle大小xdirectdataaccess可以直接访问后端资源数据库文件系统等xautomaticcodesplitting自动代码分割按需加载xstreamingsupport支持流式渲染提升用户体验什么是React服务端组件ReactServerComponents是一种新的组件类型它们在服务器上运行并渲染而不是在浏览器中这与传统的服务端渲染SSR不同RSC允许你在组件级别决定在哪里运行代码jsx这是一个服务端组件asyncfunctionBlogPostid可以直接访问数据库constpostawaitdb.posts.findByIdidreturnpost.titlepost.content为什么需要服务端组件传统的React应用面临几个挑战Bundle大小问题所有组件和依赖都需要发送到客户端数据获取复杂性需要API层来桥接前端和后端瀑布请求组件层级导致的串行数据请求SEO和首屏性能客户端渲染的固有限制RSC通过在服务器上运行组件来解决这些问题jsx传统方式需要API调用functionUserProfileuserIdconstuser,setUseruseStatenulluseEffectfetchapiusersuserId.thenresres.json.thensetUser,userIdif!userreturnLoading...returnuser.nameRSC方式直接数据访问asyncfunctionUserProfileuserIdconstuserawaitgetUserByIduserIdreturnuser.name服务端组件vs客户端组件理解两种组件类型的区别至关重要服务端组件特点jsx默认情况下组件是服务端组件asyncfunctionServerComponent可以使用asyncawaitconstdataawaitfetchData可以访问服务端APIconstfsrequirefs不能使用浏览器APIconstwidthwindow.innerWidth错误不能使用状态和生命周期constcount,setCountuseState0错误returndata.title客户端组件特点jsxuseclient明确标记为客户端组件functionClientComponent可以使用状态和事件处理constcount,setCountuseState0可以使用浏览器APIconstwidthwindow.innerWidth不能直接访问服务端资源constdataawaitdb.query错误returnsetCountcount1Countcount实际应用场景1.数据密集型应用jsx博客文章列表asyncfunctionBlogListconstpostsawaitdb.posts.findManyincludeauthortrue,tagstrue,returnposts.mappost单个博客卡片也是服务端组件asyncfunctionBlogCardpostconstcommentsCountawaitdb.comments.countwherepostIdpost.id,returnpost.titleBypost.author.namecommentsCountcomments客户端组件2.条件渲染和权限控制jsxasyncfunctionDashboarduserIdconstuserawaitgetCurrentUseruserIdif!user.isAdminreturnconststatsawaitgetAdminStatsreturnAdminDashboard3.第三方API集成jsxasyncfunctionWeatherWidgetcity在服务端调用第三方API隐藏API密钥constweatherawaitfetchhttpsapi.weather.comv1current?keyprocess.env.WEATHER_API_KEYqcity.thenresres.jsonreturncityweather.temperatureCweather.description组件组合模式RSC的强大之处在于服务端和客户端组件的无缝组合jsx服务端组件asyncfunctionProductPageproductIdconstproductawaitgetProductproductIdconstreviewsawaitgetReviewsproductIdreturn客户端组件客户端组件useclientfunctionAddToCartButtonproductIdconstisAdding,setIsAddinguseStatefalseconsthandleAddToCartasyncsetIsAddingtrueawaitaddToCartproductIdsetIsAddingfalsereturnisAdding?Adding...AddtoCart性能优化策略1.流式渲染jsximportSuspensefromreactasyncfunctionProductPageproductIdreturn这个组件会并行加载不会阻塞页面渲染asyncfunctionProductReviewsproductId模拟慢查询awaitnewPromiseresolvesetTimeoutresolve,2000constreviewsawaitgetReviewsproductIdreturn2.智能缓存jsximportcachefromreact使用Reactcache避免重复请求constgetUsercacheasyncuserIdreturnawaitdb.users.findByIduserIdasyncfunctionUserProfileuserIdconstuserawaitgetUseruserId缓存结果returnuser.nameasyncfunctionUserPostsuserIdconstuserawaitgetUseruserId复用缓存constpostsawaitgetUserPostsuserIdreturnuser.namesPostsposts.mappost在Next.js中使用Next.js13的AppRouter原生支持RSCjsxappblogpage.js服务端组件asyncfunctionBlogPageconstpostsawaitgetPostsreturnBlog客户端组件appblogslugpage.js动态路由asyncfunctionBlogPostparamsconstpostawaitgetPostparams.slugreturnpost.title客户端组件生成静态参数exportasyncfunctiongenerateStaticParamsconstpostsawaitgetPostsreturnposts.mappostslugpost.slug最佳实践1.组件边界设计jsx好的设计清晰的边界asyncfunctionShoppingCartconstitemsawaitgetCartItemsreturn客户端组件处理交互避免混合关注点asyncfunctionShoppingCartconstisOpen,setIsOpenuseStatefalse错误服务端组件不能用状态constitemsawaitgetCartItemsreturnsetIsOpen!isOpen错误服务端组件不能处理事件...2.数据获取优化jsx并行数据获取asyncfunctionDashboardconstuser,stats,notificationsawaitPromise.allgetCurrentUser,getDashboardStats,getNotificationsreturn串行数据获取asyncfunctionDashboardconstuserawaitgetCurrentUserconststatsawaitgetDashboardStats等待上一个完成constnotificationsawaitgetNotifications等待上一个完成return...3.错误处理jsxapperror.js错误边界useclientexportdefaultfunctionErrorerror,resetreturnSomethingwentwrong!resetTryagain服务端组件中的错误处理asyncfunctionUserProfileuserIdtryconstuserawaitgetUseruserIdreturncatcherroriferror.codeUSER_NOT_FOUNDreturnthrowerror让错误边界处理调试和开发工具1.ReactDevToolsReactDevTools现在支持RSC可以区分服务端和客户端组件jsx在组件中添加调试信息asyncfunctionDebugComponentconstdataawaitfetchData服务端日志console.logServer,datareturnJSON.stringifydata,null,22.性能监控jsximportunstable_traceastracefromreactasyncfunctionTrackedComponentreturntraceTrackedComponent,asyncconstdataawaitexpensiveOperationreturndata迁移策略从传统React应用迁移到RSC1.渐进式迁移jsx第一步识别可以服务端化的组件functionStaticHeaderreturnMyApp可以变成服务端组件functionInteractiveNavconstisOpen,setIsOpenuseStatefalse必须保持客户端组件return...第二步逐步转换asyncfunctionStaticHeaderconstconfigawaitgetAppConfig现在可以直接获取数据returnconfig.appName2.数据获取重构jsx之前客户端数据获取functionUserListconstusers,setUsersuseStateuseEffectfetchUsers.thensetUsers,returnusers.mapuser之后服务端数据获取asyncfunctionUserListconstusersawaitgetUsersreturnusers.mapuser未来展望ReactServerComponents正在快速发展未来可能的改进包括更好的开发工具更直观的调试体验更细粒度的缓存控制组件级别的缓存策略更好的类型安全TypeScript集成改进边缘计算支持在CDN边缘运行服务端组件总结ReactServerComponents是React生态系统的重大进步它们提供了更好的性能减少客户端bundle大小和网络请求更简单的架构消除了客户端和服务端之间的边界更好的开发体验直接的数据访问和更少的样板代码更好的用户体验更快的首屏加载和流式渲染虽然学习曲线存在但RSC为构建现代Web应用提供了强大的新范式随着生态系统的成熟它们将成为React开发的标准实践但是不是所有组件都需要是服务端组件关键是找到正确的平衡点",
    "tags": [
      "React",
      "服务端组件",
      "Next.js",
      "SSR"
    ],
    "category": "Technology",
    "date": "2025-04-20"
  },
  {
    "title": "秒杀场景的技术实现与架构设计",
    "slug": "秒杀场景的技术实现与架构设计",
    "summary": "\n## 1. 什么是秒杀场景？\n\n秒杀是指在特定时间内，用户通过线上平台以极低的价格抢购限量商品或服务的活动。秒杀场景具有以下特点：\n\n- **高并发**：短时间内大量用户同时访问系统，请求量激增。\n- **瞬时流量**：流量在秒杀开始时达到峰值，随后迅速下降。\n- **库存有限**：商品数量少，需快速判断库存并锁定。\n- **低延迟要求**：用户期望快速响应，任何延迟可能导致用户流失。\n- **公平性**：确保每个用户有公平的抢购机会，防止恶意刷单或作弊。\n\n常见的秒杀场景包括电商平台的“双 11”促销、节假日特价机票抢购、演唱会门票秒杀等。\n",
    "content": "1.什么是秒杀场景秒杀是指在特定时间内用户通过线上平台以极低的价格抢购限量商品或服务的活动秒杀场景具有以下特点高并发短时间内大量用户同时访问系统请求量激增瞬时流量流量在秒杀开始时达到峰值随后迅速下降库存有限商品数量少需快速判断库存并锁定低延迟要求用户期望快速响应任何延迟可能导致用户流失公平性确保每个用户有公平的抢购机会防止恶意刷单或作弊常见的秒杀场景包括电商平台的双11促销节假日特价机票抢购演唱会门票秒杀等2.秒杀场景的技术挑战秒杀系统的设计需要解决以下核心问题高并发处理如何应对短时间内千万级别的请求库存超卖如何确保库存不被超卖或超扣系统稳定性如何防止系统因流量过载而崩溃用户体验如何保证响应速度快操作流畅防刷与公平性如何防止恶意用户或机器人抢占资源3.秒杀系统架构设计以下是一个典型的秒杀系统架构设计分为前端网关层业务逻辑层缓存层和数据库层3.1总体架构图mermaidgraphTDA用户HTTPHTTPSBCDNB静态资源C静态文件存储B动态请求D网关层D负载均衡E应用服务层E热点数据FRedis集群E异步处理G消息队列GH订单处理服务F持久化I数据库I主从同步J数据库从库E日志K日志系统说明CDN分发静态资源如JSCSS图片降低服务器压力网关层负责流量控制限流防刷身份验证等应用服务层处理核心业务逻辑如库存校验订单生成Redis集群缓存热点数据减少数据库压力消息队列异步处理订单解耦系统数据库持久化订单和库存数据使用主从架构提高读写性能3.2前端优化前端在秒杀场景中起到重要作用主要优化点包括静态化将秒杀页面静态化存储在CDN减少后端动态渲染压力倒计时同步通过服务器时间同步确保秒杀开始时间一致请求合并对频繁的轮询请求进行合并减少后端压力防重复提交前端限制用户重复点击降低无效请求懒加载延迟加载非关键资源提升页面加载速度示例代码前端倒计时javascriptfunctionstartCountdownendTimeconsttimersetIntervalconstnownewDate.getTimeconstdistanceendTimenowifdistanceconnectionconnection.setNXlockKey.getBytes,requestId.getBytesifOK.equalsresultredisTemplate.expirelockKey,expireTime,TimeUnit.SECONDSreturntruereturnfalse3.6消息队列消息队列用于异步处理订单缓解数据库压力常用技术包括KafkaRabbitMQ等主要步骤用户抢购成功后将订单信息推送到消息队列消费者服务异步处理订单写入数据库提供订单状态查询接口供用户查看结果示例代码Kafka生产者javapublicvoidsendOrderMessageStringorderInfokafkaTemplate.sendseckill_order_topic,orderInfo3.7数据库设计数据库主要负责数据持久化优化点包括读写分离主库处理写操作从库处理读操作分库分表根据商品ID或用户ID分片降低单表压力索引优化为秒杀相关的表如订单表库存表添加索引事务精简尽量减少事务范围避免锁冲突示例SQL库存表结构sqlCREATETABLEseckill_productidBIGINTAUTO_INCREMENTPRIMARYKEY,product_idVARCHAR50NOTNULL,stockINTNOTNULLDEFAULT0,start_timeDATETIMENOTNULL,end_timeDATETIMENOTNULL,UNIQUEKEYuk_product_idproduct_id4.防刷与公平性为保证秒杀的公平性需采取以下措施验证码在秒杀前要求用户输入验证码防止机器人用户限制限制同一用户只能抢购一次如通过用户ID校验随机延迟在前端添加随机延迟防止脚本抢占行为分析通过大数据分析用户行为识别异常请求5.系统监控与容错监控使用PrometheusGrafana监控系统性能如QPS延迟错误率日志通过ELK收集日志快速定位问题容错通过Hystrix或Sentinel实现熔断防止级联失败压测使用JMeter或Locust模拟高并发验证系统容量6.总结秒杀系统是一个典型的高并发场景涉及前端优化网关限流应用服务逻辑缓存消息队列和数据库等多个层面通过合理的架构设计和优化可以有效应对高并发流量保证系统稳定性和用户体验关键点在于流量削峰通过CDN限流异步处理分散流量库存控制使用Redis原子操作防止超卖公平性通过验证码防刷机制保障公平监控与容错实时监控系统状态快速响应异常希望这篇文章对设计秒杀系统有所帮助",
    "tags": [
      "架构",
      "Java"
    ],
    "category": "Technology",
    "date": "2023-05-23"
  }
]