[
  {
    "title": "JSON Web Token认证方案",
    "slug": "JWT认证方案",
    "summary": "\nJSON Web Token（JWT）是当今最流行的跨域认证解决方案之一，广泛应用于分布式系统和前后端分离架构中。本文将详细介绍 JWT 的原理、结构、使用方式及其优缺点，理解其在现代 Web 开发中的重要性。\n\n## 一、跨域认证的挑战\n\n在互联网服务中，用户认证是不可或缺的一环。传统的认证流程通常如下：\n\n1. 用户向服务器发送用户名和密码。\n2. 服务器验证通过后，在会话（session）中存储用户相关信息，如用户 ID、角色、登录时间等。\n3. 服务器返回一个 session_id，存储在客户端的 Cookie 中。\n4. 后续请求中，客户端通过 Cookie 自动携带 session_id，服务器根据 session_id 查找会话数据以确认用户身份。\n5. 服务器根据会话数据处理请求并返回结果。\n\n这种基于 session 的认证方式在单机环境中运行良好，但在分布式系统或跨域场景中面临扩展性问题。例如，假设 A 和 B 是同一公司的两个网站，用户在 A 网站登录后，希望访问 B 网站时自动登录。如何实现？\n",
    "content": "JSONWebTokenJWT是当今最流行的跨域认证解决方案之一广泛应用于分布式系统和前后端分离架构中本文将详细介绍JWT的原理结构使用方式及其优缺点理解其在现代Web开发中的重要性一跨域认证的挑战在互联网服务中用户认证是不可或缺的一环传统的认证流程通常如下用户向服务器发送用户名和密码服务器验证通过后在会话session中存储用户相关信息如用户ID角色登录时间等服务器返回一个session_id存储在客户端的Cookie中后续请求中客户端通过Cookie自动携带session_id服务器根据session_id查找会话数据以确认用户身份服务器根据会话数据处理请求并返回结果这种基于session的认证方式在单机环境中运行良好但在分布式系统或跨域场景中面临扩展性问题例如假设A和B是同一公司的两个网站用户在A网站登录后希望访问B网站时自动登录如何实现传统方案的局限性会话数据共享在服务器集群中每台服务器需要访问共享的session数据通常通过数据库或Redis实现这增加了工程复杂性且持久层可能成为单点故障跨域限制不同域名下的Cookie无法直接共享导致跨域单点登录SSO实现困难扩展性问题随着用户量和服务器数量增加集中式session管理可能导致性能瓶颈JWT提供了一种无状态的认证方案通过将用户身份信息存储在客户端解决了上述问题二JWT的原理JWT的核心理念是服务器在验证用户身份后生成一个包含用户信息的JSON对象附加签名后发回客户端客户端在后续请求中携带此JSON对象服务器仅通过验证签名即可确认用户身份无需在服务器端存储会话数据例如服务器可能生成如下JSON对象user_id12345,roleadmin,exp1735689600这个JSON对象经过编码和签名后形成JWT令牌客户端每次请求时携带该令牌服务器验证其有效性以确认用户身份由于服务器无需存储会话数据这种方式天然适合分布式系统和跨域场景三JWT的数据结构JWT是一个由三部分组成的字符串用点号.分隔形如Header.Payload.Signature每一部分都是Base64URL编码的字符串具体作用如下3.1Header头部Header是一个JSON对象描述JWT的元数据通常包含以下字段algHS256,typJWTalg签名算法通常为HMACSHA256HS256或RSAtyp令牌类型固定为JWTHeader被Base64URL编码后形成JWT的第一部分3.2Payload负载Payload包含实际的用户数据分为官方字段和自定义字段JWT规范定义了以下官方字段ississuer签发者例如auth.example.comsubsubject主题通常是用户ID如12345audaudience受众指定令牌的接收方如api.example.comexpexpirationtime过期时间Unix时间戳如1735689600nbfnotbefore生效时间Unix时间戳iatissuedat签发时间Unix时间戳jtiJWTID唯一标识用于防止令牌重放自定义字段可以根据业务需求添加例如sub12345,name张三,roleadminPayload同样被Base64URL编码形成JWT的第二部分注意Payload默认不加密任何人都可以解码读取因此不应包含敏感信息如密码3.3Signature签名Signature用于验证JWT的完整性和真实性防止数据被篡改其生成公式为HMACSHA256base64UrlEncodeheader.base64UrlEncodepayload,secretsecret服务器私有的密钥仅服务器知道HMACSHA256默认签名算法也可使用RSA等非对称加密算法签名后HeaderPayload和Signature通过点号拼接形成完整的JWT例如eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuoYiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MzU2ODk2MDB9.dQw4w9WgXcQ3.4Base64URL编码Base64URL是一种适合URL传输的编码方式与标准Base64类似但有以下调整去掉填充字符将替换为将替换为_这确保JWT可以在URL中安全传输例如api.example.com?tokenxxx四JWT的使用方式4.1客户端存储客户端收到JWT后可以存储在以下位置Cookie通过SetCookie头自动发送但不适合跨域场景受同源策略限制localStoragesessionStorage适合前后端分离场景需手动添加到请求头HTTP请求头推荐方式将JWT放入Authorization头例如AuthorizationBearereyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...4.2跨域单点登录在跨域场景中JWT的无状态特性尤为重要例如用户在A网站a.example.com登录服务器验证后返回JWT客户端将JWT存储在localStorage或通过POST请求传递访问B网站b.example.com时客户端在请求头中携带JWTB网站的服务器使用共享的密钥验证JWT提取用户身份如sub实现自动登录4.3服务器验证服务器收到JWT后使用相同的密钥和算法重新计算签名比较计算出的签名与JWT中的签名是否一致检查Payload中的exp过期时间nbf生效时间等字段是否有效根据sub或其他字段确认用户身份处理请求五JWT的特点与优缺点5.1特点无状态性服务器不存储会话数据适合分布式系统和微服务架构跨域友好JWT存储在客户端适合跨域单点登录信息交换Payload可携带用户数据减少服务器查询如获取用户角色可扩展性支持多种签名算法如HS256RS256和加密方式5.2优点扩展性强无需共享session数据适合服务器集群和微服务跨域支持通过HTTP头或POST数据传递JWT实现跨域认证减少服务器开销无需在服务器端存储会话降低内存和数据库压力标准化遵循RFC7519规范社区支持广泛库实现丰富如jsonwebtoken5.3缺点无法主动失效由于无状态设计服务器无法在过期前主动废除JWT例如用户在设备A登录后又在设备B登录设备A的JWT仍有效除非添加额外逻辑如黑名单安全性风险JWT默认不加密Payload可被解码需避免存储敏感信息盗用风险若JWT被窃取如通过XSS攻击攻击者在有效期内可冒用身份建议设置较短的过期时间并使用HTTPS传输数据膨胀JWT包含HeaderPayload和Signature数据量较大可能增加网络开销5.4解决缺点的方法短过期时间设置较短的exp如15分钟配合refreshtoken刷新黑名单机制在Redis中维护失效JWT的jti列表检查令牌是否被废除防止重放攻击使用jti和一次性nonce或在Payload中加入时间戳验证请求的唯一性加密JWT使用JWEJSONWebEncryption对Payload加密增强安全性六JWT的应用场景单点登录SSO在多个子域名或服务间共享用户身份例如用户在auth.example.com登录后访问api.example.com时自动认证前后端分离在RESTfulAPI中客户端如ReactVue通过JWT认证用户第三方授权结合OAuth2.0JWT作为访问令牌减少对授权服务器的查询移动端认证在移动应用中JWT适合无状态认证减少服务器压力七实际示例假设一个简单的登录场景用户在前端输入用户名和密码发送到login接口服务器验证后生成JWTheaderalgHS256,typJWT,payloadsub12345,name张三,roleadmin,exp1735689600,iat1735686000服务器使用密钥mysecretkey生成签名返回JWTeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsIm5hbWUiOiLlvKDkuoYiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE3MzU2ODk2MDAsImlhdCI6MTczNTY4NjAwMH0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c客户端存储JWT例如在localStorage并在后续请求中添加AuthorizationBearereyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...服务器验证JWT的签名和有效期提取sub确认用户身份八常见问题解答8.1如何实现单设备登录若要求设备B登录后使设备A的JWT失效可在服务器端维护一个Redis表记录用户ID和最新JWT的jti验证时检查jti是否匹配不匹配则拒绝请求此方案虽引入少量状态但比session管理更轻量8.2如何防止JWT被盗用使用HTTPS加密传输防止中间人攻击设置较短的过期时间如15分钟并使用refreshtoken刷新在Payload中加入设备指纹如IP或设备ID增加验证条件通过XSS防护如CSP防止客户端存储的JWT被窃取8.3JWT与session的选择选择JWT的场景跨域认证前后端分离分布式系统第三方授权选择session的场景单机系统高安全性需求需频繁修改用户权限九总结JWT是一种轻量无状态的认证方案通过将用户身份信息编码为令牌解决了传统session在分布式和跨域场景中的局限性其标准化的结构HeaderPayloadSignature和灵活的使用方式使其成为现代Web开发的首选认证工具然而JWT的无状态特性也带来了无法主动失效和潜在的安全风险需要通过短过期时间黑名单机制和HTTPS等措施弥补理解JWT的原理和适用场景能帮助开发者设计更安全高效的认证系统",
    "tags": [
      "安全",
      "Web",
      "架构"
    ],
    "category": "Technology",
    "date": "2019-05-23"
  },
  {
    "title": "React服务端组件深度解析",
    "slug": "React服务端组件深度解析",
    "summary": "\nReact Server Components (RSC) 是 React 18 引入的革命性特性，它重新定义了我们构建 React 应用的方式。\n\n## 核心特性\n\n- [x] **[zero-bundle-impact]** 服务端组件不会增加客户端 bundle 大小\n- [x] **[direct-data-access]** 可以直接访问后端资源（数据库、文件系统等）\n- [x] **[automatic-code-splitting]** 自动代码分割，按需加载\n- [x] **[streaming-support]** 支持流式渲染，提升用户体验\n",
    "content": "ReactServerComponentsRSC是React18引入的革命性特性它重新定义了我们构建React应用的方式核心特性xzerobundleimpact服务端组件不会增加客户端bundle大小xdirectdataaccess可以直接访问后端资源数据库文件系统等xautomaticcodesplitting自动代码分割按需加载xstreamingsupport支持流式渲染提升用户体验什么是React服务端组件ReactServerComponents是一种新的组件类型它们在服务器上运行并渲染而不是在浏览器中这与传统的服务端渲染SSR不同RSC允许你在组件级别决定在哪里运行代码jsx这是一个服务端组件asyncfunctionBlogPostid可以直接访问数据库constpostawaitdb.posts.findByIdidreturnpost.titlepost.content为什么需要服务端组件传统的React应用面临几个挑战Bundle大小问题所有组件和依赖都需要发送到客户端数据获取复杂性需要API层来桥接前端和后端瀑布请求组件层级导致的串行数据请求SEO和首屏性能客户端渲染的固有限制RSC通过在服务器上运行组件来解决这些问题jsx传统方式需要API调用functionUserProfileuserIdconstuser,setUseruseStatenulluseEffectfetchapiusersuserId.thenresres.json.thensetUser,userIdif!userreturnLoading...returnuser.nameRSC方式直接数据访问asyncfunctionUserProfileuserIdconstuserawaitgetUserByIduserIdreturnuser.name服务端组件vs客户端组件理解两种组件类型的区别至关重要服务端组件特点jsx默认情况下组件是服务端组件asyncfunctionServerComponent可以使用asyncawaitconstdataawaitfetchData可以访问服务端APIconstfsrequirefs不能使用浏览器APIconstwidthwindow.innerWidth错误不能使用状态和生命周期constcount,setCountuseState0错误returndata.title客户端组件特点jsxuseclient明确标记为客户端组件functionClientComponent可以使用状态和事件处理constcount,setCountuseState0可以使用浏览器APIconstwidthwindow.innerWidth不能直接访问服务端资源constdataawaitdb.query错误returnsetCountcount1Countcount实际应用场景1.数据密集型应用jsx博客文章列表asyncfunctionBlogListconstpostsawaitdb.posts.findManyincludeauthortrue,tagstrue,returnposts.mappost单个博客卡片也是服务端组件asyncfunctionBlogCardpostconstcommentsCountawaitdb.comments.countwherepostIdpost.id,returnpost.titleBypost.author.namecommentsCountcomments客户端组件2.条件渲染和权限控制jsxasyncfunctionDashboarduserIdconstuserawaitgetCurrentUseruserIdif!user.isAdminreturnconststatsawaitgetAdminStatsreturnAdminDashboard3.第三方API集成jsxasyncfunctionWeatherWidgetcity在服务端调用第三方API隐藏API密钥constweatherawaitfetchhttpsapi.weather.comv1current?keyprocess.env.WEATHER_API_KEYqcity.thenresres.jsonreturncityweather.temperatureCweather.description组件组合模式RSC的强大之处在于服务端和客户端组件的无缝组合jsx服务端组件asyncfunctionProductPageproductIdconstproductawaitgetProductproductIdconstreviewsawaitgetReviewsproductIdreturn客户端组件客户端组件useclientfunctionAddToCartButtonproductIdconstisAdding,setIsAddinguseStatefalseconsthandleAddToCartasyncsetIsAddingtrueawaitaddToCartproductIdsetIsAddingfalsereturnisAdding?Adding...AddtoCart性能优化策略1.流式渲染jsximportSuspensefromreactasyncfunctionProductPageproductIdreturn这个组件会并行加载不会阻塞页面渲染asyncfunctionProductReviewsproductId模拟慢查询awaitnewPromiseresolvesetTimeoutresolve,2000constreviewsawaitgetReviewsproductIdreturn2.智能缓存jsximportcachefromreact使用Reactcache避免重复请求constgetUsercacheasyncuserIdreturnawaitdb.users.findByIduserIdasyncfunctionUserProfileuserIdconstuserawaitgetUseruserId缓存结果returnuser.nameasyncfunctionUserPostsuserIdconstuserawaitgetUseruserId复用缓存constpostsawaitgetUserPostsuserIdreturnuser.namesPostsposts.mappost在Next.js中使用Next.js13的AppRouter原生支持RSCjsxappblogpage.js服务端组件asyncfunctionBlogPageconstpostsawaitgetPostsreturnBlog客户端组件appblogslugpage.js动态路由asyncfunctionBlogPostparamsconstpostawaitgetPostparams.slugreturnpost.title客户端组件生成静态参数exportasyncfunctiongenerateStaticParamsconstpostsawaitgetPostsreturnposts.mappostslugpost.slug最佳实践1.组件边界设计jsx好的设计清晰的边界asyncfunctionShoppingCartconstitemsawaitgetCartItemsreturn客户端组件处理交互避免混合关注点asyncfunctionShoppingCartconstisOpen,setIsOpenuseStatefalse错误服务端组件不能用状态constitemsawaitgetCartItemsreturnsetIsOpen!isOpen错误服务端组件不能处理事件...2.数据获取优化jsx并行数据获取asyncfunctionDashboardconstuser,stats,notificationsawaitPromise.allgetCurrentUser,getDashboardStats,getNotificationsreturn串行数据获取asyncfunctionDashboardconstuserawaitgetCurrentUserconststatsawaitgetDashboardStats等待上一个完成constnotificationsawaitgetNotifications等待上一个完成return...3.错误处理jsxapperror.js错误边界useclientexportdefaultfunctionErrorerror,resetreturnSomethingwentwrong!resetTryagain服务端组件中的错误处理asyncfunctionUserProfileuserIdtryconstuserawaitgetUseruserIdreturncatcherroriferror.codeUSER_NOT_FOUNDreturnthrowerror让错误边界处理调试和开发工具1.ReactDevToolsReactDevTools现在支持RSC可以区分服务端和客户端组件jsx在组件中添加调试信息asyncfunctionDebugComponentconstdataawaitfetchData服务端日志console.logServer,datareturnJSON.stringifydata,null,22.性能监控jsximportunstable_traceastracefromreactasyncfunctionTrackedComponentreturntraceTrackedComponent,asyncconstdataawaitexpensiveOperationreturndata迁移策略从传统React应用迁移到RSC1.渐进式迁移jsx第一步识别可以服务端化的组件functionStaticHeaderreturnMyApp可以变成服务端组件functionInteractiveNavconstisOpen,setIsOpenuseStatefalse必须保持客户端组件return...第二步逐步转换asyncfunctionStaticHeaderconstconfigawaitgetAppConfig现在可以直接获取数据returnconfig.appName2.数据获取重构jsx之前客户端数据获取functionUserListconstusers,setUsersuseStateuseEffectfetchUsers.thensetUsers,returnusers.mapuser之后服务端数据获取asyncfunctionUserListconstusersawaitgetUsersreturnusers.mapuser未来展望ReactServerComponents正在快速发展未来可能的改进包括更好的开发工具更直观的调试体验更细粒度的缓存控制组件级别的缓存策略更好的类型安全TypeScript集成改进边缘计算支持在CDN边缘运行服务端组件总结ReactServerComponents是React生态系统的重大进步它们提供了更好的性能减少客户端bundle大小和网络请求更简单的架构消除了客户端和服务端之间的边界更好的开发体验直接的数据访问和更少的样板代码更好的用户体验更快的首屏加载和流式渲染虽然学习曲线存在但RSC为构建现代Web应用提供了强大的新范式随着生态系统的成熟它们将成为React开发的标准实践但是不是所有组件都需要是服务端组件关键是找到正确的平衡点",
    "tags": [
      "React",
      "服务端组件",
      "Next.js",
      "SSR"
    ],
    "category": "Technology",
    "date": "2025-04-20"
  },
  {
    "title": "RPC远程调用详解",
    "slug": "RPC远程调用",
    "summary": "\n在单机应用中，调用一个函数非常简单，直接通过函数指针或引用即可。但在分布式系统中，服务部署在不同的服务器上，如何像调用本地函数一样调用远程服务器上的函数呢？这就是 RPC 要解决的问题。\n\nRPC 的核心目标是：**让远程服务调用看起来像本地调用一样简单。**\n",
    "content": "RPCRemoteProcedureCall远程过程调用是一种计算机通信协议该协议允许运行于一台计算机的程序调用另一台计算机的子程序而程序员无需额外地为这个交互作用编程如果涉及的软件采用面向对象编程那么RPC亦可称作远程调用或远程方法调用一RPC的基本概念在单机应用中调用一个函数非常简单直接通过函数指针或引用即可但在分布式系统中服务部署在不同的服务器上如何像调用本地函数一样调用远程服务器上的函数呢这就是RPC要解决的问题RPC的核心目标是让远程服务调用看起来像本地调用一样简单二RPC的工作原理RPC的实现过程通常包含以下几个关键组件Client客户端服务的调用方ClientStub客户端存根存放服务端的地址消息将客户端的请求参数打包成网络消息再通过网络发送给服务端NetworkService网络传输底层传输可以是TCP或HTTPServerStub服务端存根接收客户端发送过来的消息将消息解包并调用本地的方法Server服务端服务的提供方调用流程客户端调用客户端Stub就像调用本地方法一样客户端Stub将参数打包序列化并通过网络发送给服务端服务端Stub接收到消息后将参数解包反序列化服务端Stub调用本地服务方法服务端执行方法并将结果返回给服务端Stub服务端Stub将结果打包序列化并通过网络发送给客户端客户端Stub接收到消息将结果解包反序列化客户端得到最终结果三RPC与REST的区别RESTRepresentationalStateTransfer是一种架构风格通常基于HTTP协议特性RPCREST核心思想动作Action强调过程资源Resource强调状态传输协议通常基于TCP或HTTP2基于HTTP1.1或HTTP2数据格式Protobuf,Thrift,Hessian等二进制格式高效JSON,XML等文本格式可读性好性能高序列化反序列化快包体小相对较低适用场景内部微服务之间的高性能通信对外API异构系统集成四常见的RPC框架gRPC由Google开发基于HTTP2和Protobuf支持多语言性能优异Dubbo阿里巴巴开源的高性能JavaRPC框架提供了完善的服务治理功能ThriftFacebook开发的跨语言RPC框架SpringCloudFeign基于HTTP的伪RPC框架使用起来非常方便但本质上是HTTP调用五RPC的优缺点优点简单易用开发者无需关注底层网络通信细节高效通常使用二进制序列化和TCP协议性能优于HTTPJSON强类型通常有IDL接口定义语言约束类型安全缺点耦合性客户端和服务端需要依赖相同的接口定义调试困难二进制协议不如JSON直观抓包调试相对麻烦复杂性引入了服务发现负载均衡熔断降级等服务治理问题六总结RPC是构建分布式系统和微服务架构的基石选择合适的RPC框架如gRPC或Dubbo可以显著提高系统的性能和开发效率但在设计系统时也需要权衡RPC和REST的适用场景通常内部服务间使用RPC对外接口使用REST",
    "tags": [
      "RPC",
      "Backend",
      "Architecture"
    ],
    "category": "Technology",
    "date": "2025-11-23"
  },
  {
    "title": "应对突发流量并保证数据一致性的一些实践",
    "slug": "应对突发流量并保证数据一致性的实践",
    "summary": "\n```text\n课程中心        ←→   Spring Cloud Gateway\n选课服务        ←→   Nacos（注册中心 + 配置中心）\n用户服务        ←→   Sentinel（限流熔断降级）",
    "content": "以下是我在一个教育项目中实践高并发选课系统峰值QPS超3w秒杀瞬间10w请求的完整技术方案总结重点解决高并发下的极致响应速度和强数据一致性两大核心问题我只提供了一些伪代码实现如需交流欢迎通过本站联系本人一整体技术架构SpringCloudJDK11text课程中心SpringCloudGateway选课服务Nacos注册中心配置中心用户服务Sentinel限流熔断降级库存服务RocketMQ事务消息实现最终一致性缓存服务RedisCluster4主4从定时任务XXLJOB监控告警PrometheusGrafanaSkyWalking数据库MySQL8.0读写分离ShardingSphereJDBC分库分表二核心高并发数据一致性实践重点1.网关层限流防刷最外层削峰技术栈SpringCloudGatewaySentinelRedisyamlSentinel热点参数限流规则针对courseIdresourceselect_courselimitAppdefaultgrade1QPS限流count5000单个课程每秒最多5000次请求strategy0controlBehavior0paramIdx0对路径中的第一个参数courseId限流paramFlowItemListburstCount10000durationInSec1注意点必须开启热点参数限流否则热门课程会被刷爆Sentinel规则持久化到Redis避免重启丢失配合自定义GlobalFilterRedisLua实现一人数一单黑名单机制2.本地缓存Redis预减库存99.9请求不打数据库核心思路Redis本地缓存CaffeineDBjavaComponentpublicclassCourseStockServiceAutowiredRedisTemplateredisTemplateRedis预热时加载privatestaticfinalStringREDUCE_STOCK_LUAifredis.callexists,KEYS11thennlocalstocktonumberredis.callget,KEYS1nifstock0thennredis.calldecr,KEYS1nreturn1nendnendnreturn0publicbooleandeductStockLongcourseIdStringkeycoursestockcourseIdLongresultredisTemplate.executenewDefaultRedisScriptREDUCE_STOCK_LUA,Long.class,Collections.singletonListkeyreturnresult1注意点课程发布时必须提前把库存写入Redis严禁使用GETDECR两步操作必须用Lua保证原子性Caffeine本地缓存TTL30ssizebased5000防止缓存雪崩热门课程主动刷新本地缓存3.异步下单RocketMQ事务消息最终一致性最佳实践javaServicepublicclassOrderServiceRocketMQTransactionListenerclassOrderTransactionListenerimplementsRocketMQLocalTransactionListenerOverridepublicRocketMQLocalTransactionStateexecuteLocalTransactionMessagemsg,Objectarg1.创建待支付订单2.MySQL乐观锁扣库存3.写入本地事务表returnsuccess?COMMITROLLBACKOverridepublicRocketMQLocalTransactionStatecheckLocalTransactionMessagemsg回查本地事务状态防止半消息丢失MySQL乐观锁扣库存sqlUPDATEcourse_stockSETstockstock1,versionversion1WHEREcourse_id?ANDstock0ANDversion?注意点事务消息消费端才是真正落单的地方回查时间建议1分钟超时视为失败比分布式锁性能高10倍以上4.超卖三层防护兜底方案层级技术方案作用第一层RedisLua预减挡住99.9请求第二层MySQL乐观锁防止漏网之鱼第三层支付前最终校验定时任务释放人工可干预的终极兜底5.数据库层优化ShardingSphereJDBC按user_id分4库8表读写分离主库写订单从库读热门课程表单独分库course_hot_01写操作通过CanalKafka同步到Elasticsearch6.Sentinel熔断降级javaSentinelResourcevalueselectCourse,blockHandlerblockHandler,fallbackfallbackpublicResultselectCourseLongcourseId...publicResultblockHandlerLongcourseId,BlockExceptionexreturnResult.fail系统繁忙请稍后重试publicResultfallbackLongcourseId,ThrowabletreturnResult.successgetDefaultCourseInfocourseId7.异步通知与补偿机制支付成功普通RocketMQ消息更新订单状态超时未支付XXLJOB每分钟扫描释放库存回补Redis三真实压测数据2024秋季开学选课首日时间点瞬时QPS平均RT成功率超卖数量开抢前10秒108,00028ms99.970峰值持续1分钟47,00045ms99.990全程10分钟平均18k32ms1000四最核心的实践经验永远不要相信前端限流所有防护必须后端实现99.9的请求不要碰数据库用Redis本地缓存搞定库存扣减必须用Lua或数据库唯一约束绝不相信业务代码逻辑高并发下单首选事务消息队列RocketMQ比分布式锁快一个数量级必须有三级防护补偿机制任何单点都可能被击穿监控必须秒级RedisQPSMQ堆积Sentinel触发次数慢查询",
    "tags": [
      "Java",
      "分布式",
      "高并发"
    ],
    "category": "Technology",
    "date": "2024-11-20"
  },
  {
    "title": "现代前端工程的演进与思考",
    "slug": "现代前端工程的演进与思考",
    "summary": "\n工程化的地基是构建工具。过去几年，我们见证了从 Webpack 一统天下到“百家争鸣”的局面，核心驱动力只有一个：**速度**。\n\n### 1. 从 JavaScript 到 Native (Rust/Go)\nWebpack 极其强大，但受限于 JavaScript 的单线程和解释执行性能，在大型项目中显得力不从心。",
    "content": "随着Web应用复杂度的指数级上升前端工程化早已突破了写页面打包的传统范畴今天的现代化前端工程化是一个以开发者体验DX为核心以用户体验UX为终点深度融合云原生能力的完整工业体系本文将从构建工具的变革资产沉淀策略自动化质量保障以及边缘交付与灰度体系四个维度探讨现代化前端工程化的核心图景一构建工具的极速变革Rust化与Bundleless工程化的地基是构建工具过去几年我们见证了从Webpack一统天下到百家争鸣的局面核心驱动力只有一个速度1.从JavaScript到NativeRustGoWebpack极其强大但受限于JavaScript的单线程和解释执行性能在大型项目中显得力不从心ViteEsbuild利用Go语言编写的Esbuild进行依赖预构建Vite将开发环境启动速度提升了数倍RspackTurbopack更是激进地用Rust重写了打包引擎特别是Rspack字节跳动开源它在保持与Webpack生态高度兼容的同时提供了接近原生代码的编译性能2.构建思维的转变Bundleless开发时现代工具如Vite在开发环境利用浏览器原生的ESM能力通过HTTP请求按需加载文件而非全量打包持久化缓存PersistentCacheWebpack5和Turbopack将缓存机制做到了极致确保持久化缓存失效前构建是零耗时的工具的选择不再仅仅看功能而是看它能否在项目膨胀10倍后依然保持秒级的热更新HMRRspack目前看来是大型存量Webpack项目迁移的最佳现代化路径二资产沉淀从组件库到设计系统工程工程化的核心目的是复用但现代化的复用不再是简单的components文件夹而是基于Monorepo的原子化设计系统1.组件分层策略HeadlessUI逻辑与样式分离使用ReactAria或RadixUI处理复杂的交互逻辑无障碍访问键盘导航自建样式层原子化CSSTailwindCSS的流行改变了组件样式的编写方式它让DesignToken设计变量的落地变得异常简单2.隔离与文档化StorybookDumi组件开发必须独立于业务项目通过Storybook进行隔离开发不仅强迫组件解耦还自动生成了可视化的文档MonorepoTurborepoNx现代前端倾向于将组件库工具库业务应用放在同一个Monorepo中利用Turborepo的缓存机制修改一个Button组件CI仅会重新构建依赖该Button的应用而非整个仓库三自动化测试构建敢于重构的信心在敏捷开发中没有自动化测试的工程化是脆弱的现代测试策略呈金字塔状但重心正在发生微妙偏移1.单元测试UnitTestVitest替代Jest成为新宠它与Vite共享配置和转换逻辑速度极快解决了测试环境与生产环境构建逻辑不一致的痛点2.端到端测试E2EPlaywrightCypress现代E2E工具非常稳定且易于调试核心思考现在的趋势是减少复杂的单元测试增加关键路径的E2E测试与其测试Click函数是否被调用不如测试用户点击后页面是否真的发生了跳转3.视觉回归测试VisualRegression在组件库更新时如何确保没有破坏UI工具如Percy或Chromatic会在CI阶段截图对比像素级的差异都会触发布署拦截四部署与交付边缘计算与灰度体系代码合并只是开始如何安全快速地将代码交付给全球用户是现代化工程化的最后一公里1.自动化部署到边缘节点EdgeDeployment传统的部署是将静态资源扔到Nginx或S3现代部署则是静态资源CDN边缘计算EdgeFunctions边缘函数利用Vercel,Netlify或CloudflareWorkers我们可以将部分后端逻辑如鉴权SSR渲染AB测试分流下沉到离用户最近的CDN节点执行ISR增量静态再生成结合Next.js可以在边缘节点缓存动态生成的页面既有静态页面的速度又有动态页面的灵活性2.灰度发布与特性开关FeatureFlags上线即全量是危险的现代工程化要求部署Deploy和发布Release分离CanaryRelease金丝雀发布通过负载均衡或边缘网关先将5的流量切给新版本结合Sentry等监控工具如果发现报错率飙升自动回滚FeatureFlags代码中埋入开关如LaunchDarkly或自研系统新功能上线时默认关闭通过后台配置对特定用户群体如内部员工Beta用户开启这消除了长分支开发的痛苦允许主干随时可发布现代化前端工程化本质上是将不确定性通过工具转化为确定性的过程构建工具解决了开发效率的确定性组件沉淀解决了UI一致性的确定性自动化测试解决了代码质量的确定性边缘部署与灰度解决了交付稳定性的确定性未来的前端工程师不仅是界面的实现者更是应用交付架构师我们需要关注的不再仅仅是div怎么写而是代码如何以最快最安全的方式流动到用户的屏幕上",
    "tags": [
      "前端",
      "思考",
      "Next.js"
    ],
    "category": "Technology",
    "date": "2025-08-17"
  },
  {
    "title": "秒杀场景的技术实现与架构设计",
    "slug": "秒杀场景的技术实现与架构设计",
    "summary": "\n## 1. 什么是秒杀场景？\n\n秒杀是指在特定时间内，用户通过线上平台以极低的价格抢购限量商品或服务的活动。秒杀场景具有以下特点：\n\n- **高并发**：短时间内大量用户同时访问系统，请求量激增。\n- **瞬时流量**：流量在秒杀开始时达到峰值，随后迅速下降。\n- **库存有限**：商品数量少，需快速判断库存并锁定。\n- **低延迟要求**：用户期望快速响应，任何延迟可能导致用户流失。\n- **公平性**：确保每个用户有公平的抢购机会，防止恶意刷单或作弊。\n\n常见的秒杀场景包括电商平台的“双 11”促销、节假日特价机票抢购、演唱会门票秒杀等。\n",
    "content": "1.什么是秒杀场景秒杀是指在特定时间内用户通过线上平台以极低的价格抢购限量商品或服务的活动秒杀场景具有以下特点高并发短时间内大量用户同时访问系统请求量激增瞬时流量流量在秒杀开始时达到峰值随后迅速下降库存有限商品数量少需快速判断库存并锁定低延迟要求用户期望快速响应任何延迟可能导致用户流失公平性确保每个用户有公平的抢购机会防止恶意刷单或作弊常见的秒杀场景包括电商平台的双11促销节假日特价机票抢购演唱会门票秒杀等2.秒杀场景的技术挑战秒杀系统的设计需要解决以下核心问题高并发处理如何应对短时间内千万级别的请求库存超卖如何确保库存不被超卖或超扣系统稳定性如何防止系统因流量过载而崩溃用户体验如何保证响应速度快操作流畅防刷与公平性如何防止恶意用户或机器人抢占资源3.秒杀系统架构设计以下是一个典型的秒杀系统架构设计分为前端网关层业务逻辑层缓存层和数据库层3.1总体架构图mermaidgraphTDA用户HTTPHTTPSBCDNB静态资源C静态文件存储B动态请求D网关层D负载均衡E应用服务层E热点数据FRedis集群E异步处理G消息队列GH订单处理服务F持久化I数据库I主从同步J数据库从库E日志K日志系统说明CDN分发静态资源如JSCSS图片降低服务器压力网关层负责流量控制限流防刷身份验证等应用服务层处理核心业务逻辑如库存校验订单生成Redis集群缓存热点数据减少数据库压力消息队列异步处理订单解耦系统数据库持久化订单和库存数据使用主从架构提高读写性能3.2前端优化前端在秒杀场景中起到重要作用主要优化点包括静态化将秒杀页面静态化存储在CDN减少后端动态渲染压力倒计时同步通过服务器时间同步确保秒杀开始时间一致请求合并对频繁的轮询请求进行合并减少后端压力防重复提交前端限制用户重复点击降低无效请求懒加载延迟加载非关键资源提升页面加载速度示例代码前端倒计时javascriptfunctionstartCountdownendTimeconsttimersetIntervalconstnownewDate.getTimeconstdistanceendTimenowifdistanceconnectionconnection.setNXlockKey.getBytes,requestId.getBytesifOK.equalsresultredisTemplate.expirelockKey,expireTime,TimeUnit.SECONDSreturntruereturnfalse3.6消息队列消息队列用于异步处理订单缓解数据库压力常用技术包括KafkaRabbitMQ等主要步骤用户抢购成功后将订单信息推送到消息队列消费者服务异步处理订单写入数据库提供订单状态查询接口供用户查看结果示例代码Kafka生产者javapublicvoidsendOrderMessageStringorderInfokafkaTemplate.sendseckill_order_topic,orderInfo3.7数据库设计数据库主要负责数据持久化优化点包括读写分离主库处理写操作从库处理读操作分库分表根据商品ID或用户ID分片降低单表压力索引优化为秒杀相关的表如订单表库存表添加索引事务精简尽量减少事务范围避免锁冲突示例SQL库存表结构sqlCREATETABLEseckill_productidBIGINTAUTO_INCREMENTPRIMARYKEY,product_idVARCHAR50NOTNULL,stockINTNOTNULLDEFAULT0,start_timeDATETIMENOTNULL,end_timeDATETIMENOTNULL,UNIQUEKEYuk_product_idproduct_id4.防刷与公平性为保证秒杀的公平性需采取以下措施验证码在秒杀前要求用户输入验证码防止机器人用户限制限制同一用户只能抢购一次如通过用户ID校验随机延迟在前端添加随机延迟防止脚本抢占行为分析通过大数据分析用户行为识别异常请求5.系统监控与容错监控使用PrometheusGrafana监控系统性能如QPS延迟错误率日志通过ELK收集日志快速定位问题容错通过Hystrix或Sentinel实现熔断防止级联失败压测使用JMeter或Locust模拟高并发验证系统容量6.总结秒杀系统是一个典型的高并发场景涉及前端优化网关限流应用服务逻辑缓存消息队列和数据库等多个层面通过合理的架构设计和优化可以有效应对高并发流量保证系统稳定性和用户体验关键点在于流量削峰通过CDN限流异步处理分散流量库存控制使用Redis原子操作防止超卖公平性通过验证码防刷机制保障公平监控与容错实时监控系统状态快速响应异常希望这篇文章对设计秒杀系统有所帮助",
    "tags": [
      "架构",
      "Java"
    ],
    "category": "Technology",
    "date": "2023-05-23"
  }
]