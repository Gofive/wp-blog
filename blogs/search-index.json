[
  {
    "title": "React服务端组件深度解析",
    "slug": "React服务端组件深度解析",
    "summary": "\nReact Server Components (RSC) 是 React 18 引入的革命性特性，它重新定义了我们构建 React 应用的方式。\n\n## 核心特性\n\n- [x] **[zero-bundle-impact]** 服务端组件不会增加客户端 bundle 大小\n- [x] **[direct-data-access]** 可以直接访问后端资源（数据库、文件系统等）\n- [x] **[automatic-code-splitting]** 自动代码分割，按需加载\n- [x] **[streaming-support]** 支持流式渲染，提升用户体验\n",
    "content": "ReactServerComponentsRSC是React18引入的革命性特性它重新定义了我们构建React应用的方式核心特性xzerobundleimpact服务端组件不会增加客户端bundle大小xdirectdataaccess可以直接访问后端资源数据库文件系统等xautomaticcodesplitting自动代码分割按需加载xstreamingsupport支持流式渲染提升用户体验什么是React服务端组件ReactServerComponents是一种新的组件类型它们在服务器上运行并渲染而不是在浏览器中这与传统的服务端渲染SSR不同RSC允许你在组件级别决定在哪里运行代码jsx这是一个服务端组件asyncfunctionBlogPostid可以直接访问数据库constpostawaitdb.posts.findByIdidreturnpost.titlepost.content为什么需要服务端组件传统的React应用面临几个挑战Bundle大小问题所有组件和依赖都需要发送到客户端数据获取复杂性需要API层来桥接前端和后端瀑布请求组件层级导致的串行数据请求SEO和首屏性能客户端渲染的固有限制RSC通过在服务器上运行组件来解决这些问题jsx传统方式需要API调用functionUserProfileuserIdconstuser,setUseruseStatenulluseEffectfetchapiusersuserId.thenresres.json.thensetUser,userIdif!userreturnLoading...returnuser.nameRSC方式直接数据访问asyncfunctionUserProfileuserIdconstuserawaitgetUserByIduserIdreturnuser.name服务端组件vs客户端组件理解两种组件类型的区别至关重要服务端组件特点jsx默认情况下组件是服务端组件asyncfunctionServerComponent可以使用asyncawaitconstdataawaitfetchData可以访问服务端APIconstfsrequirefs不能使用浏览器APIconstwidthwindow.innerWidth错误不能使用状态和生命周期constcount,setCountuseState0错误returndata.title客户端组件特点jsxuseclient明确标记为客户端组件functionClientComponent可以使用状态和事件处理constcount,setCountuseState0可以使用浏览器APIconstwidthwindow.innerWidth不能直接访问服务端资源constdataawaitdb.query错误returnsetCountcount1Countcount实际应用场景1.数据密集型应用jsx博客文章列表asyncfunctionBlogListconstpostsawaitdb.posts.findManyincludeauthortrue,tagstruereturnposts.mappost单个博客卡片也是服务端组件asyncfunctionBlogCardpostconstcommentsCountawaitdb.comments.countwherepostIdpost.idreturnpost.titleBypost.author.namecommentsCountcomments客户端组件2.条件渲染和权限控制jsxasyncfunctionDashboarduserIdconstuserawaitgetCurrentUseruserIdif!user.isAdminreturnconststatsawaitgetAdminStatsreturnAdminDashboard3.第三方API集成jsxasyncfunctionWeatherWidgetcity在服务端调用第三方API隐藏API密钥constweatherawaitfetchhttpsapi.weather.comv1current?keyprocess.env.WEATHER_API_KEYqcity.thenresres.jsonreturncityweather.temperatureCweather.description组件组合模式RSC的强大之处在于服务端和客户端组件的无缝组合jsx服务端组件asyncfunctionProductPageproductIdconstproductawaitgetProductproductIdconstreviewsawaitgetReviewsproductIdreturn客户端组件客户端组件useclientfunctionAddToCartButtonproductIdconstisAdding,setIsAddinguseStatefalseconsthandleAddToCartasyncsetIsAddingtrueawaitaddToCartproductIdsetIsAddingfalsereturnisAdding?Adding...AddtoCart性能优化策略1.流式渲染jsximportSuspensefromreactasyncfunctionProductPageproductIdreturn这个组件会并行加载不会阻塞页面渲染asyncfunctionProductReviewsproductId模拟慢查询awaitnewPromiseresolvesetTimeoutresolve,2000constreviewsawaitgetReviewsproductIdreturn2.智能缓存jsximportcachefromreact使用Reactcache避免重复请求constgetUsercacheasyncuserIdreturnawaitdb.users.findByIduserIdasyncfunctionUserProfileuserIdconstuserawaitgetUseruserId缓存结果returnuser.nameasyncfunctionUserPostsuserIdconstuserawaitgetUseruserId复用缓存constpostsawaitgetUserPostsuserIdreturnuser.namesPostsposts.mappost在Next.js中使用Next.js13的AppRouter原生支持RSCjsxappblogpage.js服务端组件asyncfunctionBlogPageconstpostsawaitgetPostsreturnBlog客户端组件appblogslugpage.js动态路由asyncfunctionBlogPostparamsconstpostawaitgetPostparams.slugreturnpost.title客户端组件生成静态参数exportasyncfunctiongenerateStaticParamsconstpostsawaitgetPostsreturnposts.mappostslugpost.slug最佳实践1.组件边界设计jsx好的设计清晰的边界asyncfunctionShoppingCartconstitemsawaitgetCartItemsreturn客户端组件处理交互避免混合关注点asyncfunctionShoppingCartconstisOpen,setIsOpenuseStatefalse错误服务端组件不能用状态constitemsawaitgetCartItemsreturnsetIsOpen!isOpen错误服务端组件不能处理事件...2.数据获取优化jsx并行数据获取asyncfunctionDashboardconstuser,stats,notificationsawaitPromise.allgetCurrentUser,getDashboardStats,getNotificationsreturn串行数据获取asyncfunctionDashboardconstuserawaitgetCurrentUserconststatsawaitgetDashboardStats等待上一个完成constnotificationsawaitgetNotifications等待上一个完成return...3.错误处理jsxapperror.js错误边界useclientexportdefaultfunctionErrorerror,resetreturnSomethingwentwrong!resetTryagain服务端组件中的错误处理asyncfunctionUserProfileuserIdtryconstuserawaitgetUseruserIdreturncatcherroriferror.codeUSER_NOT_FOUNDreturnthrowerror让错误边界处理调试和开发工具1.ReactDevToolsReactDevTools现在支持RSC可以区分服务端和客户端组件jsx在组件中添加调试信息asyncfunctionDebugComponentconstdataawaitfetchData服务端日志console.logServer,datareturnJSON.stringifydata,null,22.性能监控jsximportunstable_traceastracefromreactasyncfunctionTrackedComponentreturntraceTrackedComponent,asyncconstdataawaitexpensiveOperationreturndata迁移策略从传统React应用迁移到RSC1.渐进式迁移jsx第一步识别可以服务端化的组件functionStaticHeaderreturnMyApp可以变成服务端组件functionInteractiveNavconstisOpen,setIsOpenuseStatefalse必须保持客户端组件return...第二步逐步转换asyncfunctionStaticHeaderconstconfigawaitgetAppConfig现在可以直接获取数据returnconfig.appName2.数据获取重构jsx之前客户端数据获取functionUserListconstusers,setUsersuseStateuseEffectfetchUsers.thensetUsers,returnusers.mapuser之后服务端数据获取asyncfunctionUserListconstusersawaitgetUsersreturnusers.mapuser未来展望ReactServerComponents正在快速发展未来可能的改进包括更好的开发工具更直观的调试体验更细粒度的缓存控制组件级别的缓存策略更好的类型安全TypeScript集成改进边缘计算支持在CDN边缘运行服务端组件总结ReactServerComponents代表了React生态系统的重大进步它们提供了更好的性能减少客户端bundle大小和网络请求更简单的架构消除了客户端和服务端之间的边界更好的开发体验直接的数据访问和更少的样板代码更好的用户体验更快的首屏加载和流式渲染虽然学习曲线存在但RSC为构建现代Web应用提供了强大的新范式随着生态系统的成熟它们将成为React开发的标准实践开始使用RSC的最佳方式是在新项目中尝试Next.js13的AppRouter或者在现有项目中逐步迁移适合的组件记住不是所有组件都需要是服务端组件关键是找到正确的平衡点",
    "tags": [
      "react",
      "server-components",
      "next.js",
      "ssr"
    ],
    "category": "Technology",
    "date": "2025-01-23"
  },
  {
    "title": "秒杀场景的技术实现与架构设计",
    "slug": "秒杀场景的技术实现与架构设计",
    "summary": "\n## 1. 什么是秒杀场景？\n\n秒杀是指在特定时间内，用户通过线上平台以极低的价格抢购限量商品或服务的活动。秒杀场景具有以下特点：\n\n- **高并发**：短时间内大量用户同时访问系统，请求量激增。\n- **瞬时流量**：流量在秒杀开始时达到峰值，随后迅速下降。\n- **库存有限**：商品数量少，需快速判断库存并锁定。\n- **低延迟要求**：用户期望快速响应，任何延迟可能导致用户流失。\n- **公平性**：确保每个用户有公平的抢购机会，防止恶意刷单或作弊。\n\n常见的秒杀场景包括电商平台的“双 11”促销、节假日特价机票抢购、演唱会门票秒杀等。\n",
    "content": "1.什么是秒杀场景秒杀是指在特定时间内用户通过线上平台以极低的价格抢购限量商品或服务的活动秒杀场景具有以下特点高并发短时间内大量用户同时访问系统请求量激增瞬时流量流量在秒杀开始时达到峰值随后迅速下降库存有限商品数量少需快速判断库存并锁定低延迟要求用户期望快速响应任何延迟可能导致用户流失公平性确保每个用户有公平的抢购机会防止恶意刷单或作弊常见的秒杀场景包括电商平台的双11促销节假日特价机票抢购演唱会门票秒杀等2.秒杀场景的技术挑战秒杀系统的设计需要解决以下核心问题高并发处理如何应对短时间内千万级别的请求库存超卖如何确保库存不被超卖或超扣系统稳定性如何防止系统因流量过载而崩溃用户体验如何保证响应速度快操作流畅防刷与公平性如何防止恶意用户或机器人抢占资源3.秒杀系统架构设计以下是一个典型的秒杀系统架构设计分为前端网关层业务逻辑层缓存层和数据库层3.1总体架构图mermaidgraphTDA用户HTTPHTTPSBCDNB静态资源C静态文件存储B动态请求D网关层D负载均衡E应用服务层E热点数据FRedis集群E异步处理G消息队列GH订单处理服务F持久化I数据库I主从同步J数据库从库E日志K日志系统说明CDN分发静态资源如JSCSS图片降低服务器压力网关层负责流量控制限流防刷身份验证等应用服务层处理核心业务逻辑如库存校验订单生成Redis集群缓存热点数据减少数据库压力消息队列异步处理订单解耦系统数据库持久化订单和库存数据使用主从架构提高读写性能3.2前端优化前端在秒杀场景中起到重要作用主要优化点包括静态化将秒杀页面静态化存储在CDN减少后端动态渲染压力倒计时同步通过服务器时间同步确保秒杀开始时间一致请求合并对频繁的轮询请求进行合并减少后端压力防重复提交前端限制用户重复点击降低无效请求懒加载延迟加载非关键资源提升页面加载速度示例代码前端倒计时javascriptfunctionstartCountdownendTimeconsttimersetIntervalconstnownewDate.getTimeconstdistanceendTimenowifdistanceconnectionconnection.setNXlockKey.getBytes,requestId.getBytesifOK.equalsresultredisTemplate.expirelockKey,expireTime,TimeUnit.SECONDSreturntruereturnfalse3.6消息队列消息队列用于异步处理订单缓解数据库压力常用技术包括KafkaRabbitMQ等主要步骤用户抢购成功后将订单信息推送到消息队列消费者服务异步处理订单写入数据库提供订单状态查询接口供用户查看结果示例代码Kafka生产者javapublicvoidsendOrderMessageStringorderInfokafkaTemplate.sendseckill_order_topic,orderInfo3.7数据库设计数据库主要负责数据持久化优化点包括读写分离主库处理写操作从库处理读操作分库分表根据商品ID或用户ID分片降低单表压力索引优化为秒杀相关的表如订单表库存表添加索引事务精简尽量减少事务范围避免锁冲突示例SQL库存表结构sqlCREATETABLEseckill_productidBIGINTAUTO_INCREMENTPRIMARYKEY,product_idVARCHAR50NOTNULL,stockINTNOTNULLDEFAULT0,start_timeDATETIMENOTNULL,end_timeDATETIMENOTNULL,UNIQUEKEYuk_product_idproduct_id4.防刷与公平性为保证秒杀的公平性需采取以下措施验证码在秒杀前要求用户输入验证码防止机器人用户限制限制同一用户只能抢购一次如通过用户ID校验随机延迟在前端添加随机延迟防止脚本抢占行为分析通过大数据分析用户行为识别异常请求5.系统监控与容错监控使用PrometheusGrafana监控系统性能如QPS延迟错误率日志通过ELK收集日志快速定位问题容错通过Hystrix或Sentinel实现熔断防止级联失败压测使用JMeter或Locust模拟高并发验证系统容量6.总结秒杀系统是一个典型的高并发场景涉及前端优化网关限流应用服务逻辑缓存消息队列和数据库等多个层面通过合理的架构设计和优化可以有效应对高并发流量保证系统稳定性和用户体验关键点在于流量削峰通过CDN限流异步处理分散流量库存控制使用Redis原子操作防止超卖公平性通过验证码防刷机制保障公平监控与容错实时监控系统状态快速响应异常希望这篇文章对设计秒杀系统有所帮助",
    "tags": [
      "架构",
      "Java"
    ],
    "category": "Technology",
    "date": "2023-01-23"
  }
]